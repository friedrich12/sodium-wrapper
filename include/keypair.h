// keypair.h -- Public/Private Key Pair Wrapper
//
// ISC License
//
// Copyright (C) 2018 Farid Hajji <farid@hajji.name>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#pragma once

#include "helpers.h"
#include "key.h"
#include <sodium.h>
#include <type_traits>

namespace sodium {

template<typename PK = bytes,
         typename SEED_TYPE = bytes_protected,
         typename T = typename std::enable_if<
           std::is_same<SEED_TYPE, sodium::bytes_protected>::value,
           int>::type>
class keypair
{
    /**
     * The class sodium::keypair represents a pair of public key /
     * private key used in various public key cryptography functions of
     * the libsodium library.
     *
     * The public key is stored in PK (default unprotected sodium::bytes,
     * but could be changed to sodium::bytes_protected is desired),
     * while the private key, being sensitive, is stored in
     * sodium::bytes_protected memory, i.e. in an internal sodium::key
     * object.
     *
     * A keypair provides non-mutable data()/size() access to the bytes
     * of the public/private keys in a uniform fashion via the
     * public_key() and private_key() accessors.
     *
     * A keypair can be constructed randomly, or deterministically by
     * providing a seed. Furthermore, given a private key previously
     * generated by keypair or the underlying libsodium functions,
     * the corresponding public key can be derived and a keypair
     * constructed.
     **/

  public:
    // common constants for typical key and seed sizes
    static constexpr std::size_t KEYSIZE_PUBLIC_KEY = crypto_box_PUBLICKEYBYTES;
    static constexpr std::size_t KEYSIZE_PRIVATE_KEY =
      crypto_box_SECRETKEYBYTES;
    static constexpr std::size_t KEYSIZE_SEEDBYTES = crypto_box_SEEDBYTES;

    using private_key_type = key<KEYSIZE_PRIVATE_KEY>;
    using public_key_type = PK;
    using seed_type = SEED_TYPE;

    /**
     * Generate a new (random) key pair of public/private keys.
     *
     * The created keypair contains a public key with KEYSIZE_PUBLIC_KEY bytes,
     * and a private key with KEYSIZE_PRIVATE_KEY bytes. Both keys are related
     * and must be used together.
     *
     * Underlying libsodium function: crypto_box_keypair().
     *
     * the private key is stored in an internal key object in protected
     * key_type memory (readonly). It will be wiped clean when the keypair
     * goes out of scope or is destroyed.
     *
     * The public key is stored in an internal bytes object in
     * unprotected (readwrite) memory.
     **/

    keypair()
      : public_key_(KEYSIZE_PUBLIC_KEY, '\0')
      , private_key_(false)
    {
        crypto_box_keypair(reinterpret_cast<unsigned char*>(public_key_.data()),
                           private_key_.setdata());
        private_key_.readonly();
    }

    /**
     * Deterministically generate a key pair of public/private keys.
     *
     * The created keypair depends on a seed which must have KEYSIZE_SEEDBYTES
     * bytes. The same public/private keys will be generated for the same
     * seeds. Providing a seed of wrong size will throw a std::runtime_error.
     *
     * Underlying libsodium function: crypto_box_seed_keypair().
     *
     * Otherwise, see keypair().
     **/

    keypair(const seed_type& seed)
      : public_key_(KEYSIZE_PUBLIC_KEY, '\0')
      , private_key_(false)
    {
        if (seed.size() != KEYSIZE_SEEDBYTES)
            throw std::runtime_error{
                "sodium::keypair::keypair(seed) wrong seed size"
            };
        crypto_box_seed_keypair(
          reinterpret_cast<unsigned char*>(public_key_.data()),
          private_key_.setdata(),
          reinterpret_cast<const unsigned char*>(seed.data()));
        private_key_.readonly();
    }

    /**
     * Given a previously calculated private key whose privkey_size
     * bytes are stored starting at privkey_data, derive the
     * corresponding public key public_key, and construct with privkey_data
     * and pubkey a new keypair. private_key_data MUST point to
     * KEYSIZE_PRIVATE_KEY bytes as shown by privkey_size, of course, or
     * this constructor will throw a std::runtime_error. The bytes at
     * privkey_data must be accessible or readable, or the program will
     * terminate.
     *
     * Underlying libsodium function: crypto_scalarmult_base().
     *
     * Note that the bytes at privkey_data MUST have been generated by
     * calculation, i.e.  by calls to keypair() constructors or
     * underlying libsodium functions. Undefined behavior results if
     * this is not the case.
     *
     * Otherwise, see keypair().
     **/

    keypair(const byte* private_key_data, const std::size_t private_key_size)
      : public_key_(KEYSIZE_PUBLIC_KEY, '\0')
      , private_key_(false)
    {
        if (private_key_size != KEYSIZE_PRIVATE_KEY)
            throw std::runtime_error{
                "sodium::keypair::keypair(private_key_data, private_key_size) "
                "wrong private_key_size"
            };
        std::copy(private_key_data,
                  private_key_data + private_key_size,
                  private_key_.setdata()); // constant time

        // public key can be reconstructed from private key
        // previously computed by crypto_box_[seed_]keypair()!
        crypto_scalarmult_base(
          reinterpret_cast<unsigned char*>(public_key_.data()),
          private_key_.data());

        private_key_.readonly();
    }

    /**
     * Copy and move constructors
     **/

    template<typename U>
    keypair(const keypair<U>& other)
      : public_key_(other.public_key())
      , private_key_(other.private_key())
    {}

    template<typename U>
    keypair(keypair<U>&& other)
      : public_key_(std::move(other.public_key_))
      , private_key_(std::move(other.private_key_))
    {}

    /**
     * Give const access to the stored private key as a key object.
     *
     * This can be used to access the bytes of the private key via a
     * non-mutable data()/size() interface like this:
     *   <SOME_KEYPAIR>.private_key().data(),
     *<SOME_KEYPAIR>.private_key().size()
     **/

    const private_key_type& private_key() const { return private_key_; }

    /**
     * Give const access to the stored public key as a bytes object.
     *
     * This can be used to access the bytes of the public key via a
     * non-mutable data()/size() interface like this:
     *  <SOME_KEYPAIR>.public_key().data(), <SOME_KEYPAIR>.public_key().size()
     **/

    const public_key_type& public_key() const { return public_key_; }
    public_key_type public_key_;
    private_key_type private_key_;
  private:
};

} // namespace sodium

template<typename PK1 = sodium::bytes, typename PK2 = sodium::bytes>
bool
operator==(const sodium::keypair<PK1>& kp1, const sodium::keypair<PK2>& kp2)
{
    // Compare public keys and private keys in constant time:

    return
      // selects sodium::compare<PK1,PK2>()
      sodium::compare(kp1.public_key(), kp2.public_key()) &&
      // uses operator==(sodium::key<KEYSIZE_PRIVATE_KEY>,
      //                 sodium::key<KEYSIZE_PRIVATE_KEY>)
      kp1.private_key() == kp2.private_key();
}

template<typename PK1 = sodium::bytes, typename PK2 = sodium::bytes>
bool
operator!=(const sodium::keypair<PK1>& kp1, const sodium::keypair<PK2>& kp2)
{
    return (!(kp1 == kp2));
}
